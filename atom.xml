<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://quwater.github.io/</id>
    <title>Qcloud</title>
    <updated>2022-01-01T14:20:00.898Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://quwater.github.io/"/>
    <link rel="self" href="https://quwater.github.io/atom.xml"/>
    <subtitle>你爱吃鲔鱼罐头吗？</subtitle>
    <logo>https://quwater.github.io/images/avatar.png</logo>
    <icon>https://quwater.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Qcloud</rights>
    <entry>
        <title type="html"><![CDATA[关于 2022 年读书写作的碎碎念]]></title>
        <id>https://quwater.github.io/post/guan-yu-2022-nian-du-shu-xie-zuo-de-sui-sui-nian/</id>
        <link href="https://quwater.github.io/post/guan-yu-2022-nian-du-shu-xie-zuo-de-sui-sui-nian/">
        </link>
        <updated>2022-01-01T14:17:24.000Z</updated>
        <summary type="html"><![CDATA[<p><img src="https://quwater.github.io//post-images/1641046775389.png" alt="" loading="lazy"><br>
去年主要看了五六本推理小说，四本科幻小说，严肃文学看了两三本，杂志主要看了中信出的新哲人系列，网络小说若干，值得铭记读到尾的只有 priest 的书。</p>
<p>可惜读后感之写了三篇，远远不及自己之前的规划。</p>
]]></summary>
        <content type="html"><![CDATA[<p><img src="https://quwater.github.io//post-images/1641046775389.png" alt="" loading="lazy"><br>
去年主要看了五六本推理小说，四本科幻小说，严肃文学看了两三本，杂志主要看了中信出的新哲人系列，网络小说若干，值得铭记读到尾的只有 priest 的书。</p>
<p>可惜读后感之写了三篇，远远不及自己之前的规划。</p>
<!-- more -->
<p>新的一年，不说太多，按照浅墨的读书笔记风格，每周至少认真读两本自己喜欢的书，做好读书笔记。</p>
<p>严肃文学可能会看的比较少，更多想要阅读通俗一点的，依然还是以推理为主（周末一口气读完即可，每月一本）</p>
<p>至于网络小说，自己喜欢的东西就该努力完成，没有什么借口。</p>
<p>非虚构类的书籍，书单已经快要爆炸了，得清理一下，（每月一本即可）</p>
<p>技术类的书籍，除了那几本每年必须要读的书籍以外，公开课内容至少完成（复习）两门（CSAPP 与计算机网络部分）</p>
<p>关于写作，一百万字算是底线。</p>
<p>虽然用量来算这些十分粗糙，但起码在自己现在这个阶段还算有效。</p>
<p>加油，新一年的小鱼。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《成年人的谎言生活》读后碎碎念]]></title>
        <id>https://quwater.github.io/post/lesslesscheng-nian-ren-de-huang-yan-sheng-huo-greatergreater-du-hou-sui-sui-nian/</id>
        <link href="https://quwater.github.io/post/lesslesscheng-nian-ren-de-huang-yan-sheng-huo-greatergreater-du-hou-sui-sui-nian/">
        </link>
        <updated>2021-12-31T14:11:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>我青春期的时间过得很慢，是由一大段一大段灰暗的时光组成，中间也会突然冒出绿色、红色或紫色。这些时间段没有具体的年月日和时辰，季节也不是很确定，不知道是冷是热，也不知道是下雨还是阳光灿烂。那些意外出现的色彩也没有具体的时间，它们的颜色比时间重要。除此之外，那些色彩代表着一些持续时间很短的激情。写下这些文字的人心里很清楚，当你刚开始寻觅词句，当时那些缓慢的时间就变成了旋涡，色彩混合在一起，就像搅拌机里不同颜色的水果。</p>
</blockquote>
<p>年龄越大，越发现契机的重要性，不管是和人相遇，还是和书相遇。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>我青春期的时间过得很慢，是由一大段一大段灰暗的时光组成，中间也会突然冒出绿色、红色或紫色。这些时间段没有具体的年月日和时辰，季节也不是很确定，不知道是冷是热，也不知道是下雨还是阳光灿烂。那些意外出现的色彩也没有具体的时间，它们的颜色比时间重要。除此之外，那些色彩代表着一些持续时间很短的激情。写下这些文字的人心里很清楚，当你刚开始寻觅词句，当时那些缓慢的时间就变成了旋涡，色彩混合在一起，就像搅拌机里不同颜色的水果。</p>
</blockquote>
<p>年龄越大，越发现契机的重要性，不管是和人相遇，还是和书相遇。</p>
<!-- more -->
<p>因为 b 站上读书 up 主热的兴起，经常能够看到最近上市的书籍，也是因为这个契机，开始想着尝试追一下最新的热书。</p>
<p>虽然说经典的书都应该能经得起时间的考验，但实时的参与更能够增加读书的兴致与专注，尤其是在自己的大脑已经被短视频和无穷无尽泥沙俱下的文字信息侵占的当下，就更加有意义了。</p>
<p>于是就发现了这本今年大热的书，《成年人的谎言生活》。</p>
<p>起初，这本书还只是待在我的待读书单里，优先级并不算高，毕竟我在此之前已经知道此书的作者之前写过那不勒斯四部曲，对于这种风格的书籍，我至今还从未尝试过，想着先看看前者再说。</p>
<p>然后就被班长推荐了，于是就被列入今年必读的书籍。</p>
<p>直到2021 年的最后一天终于读完。</p>
<p>这倒不是说这本书不吸引我，光是前面两章，就让我重复读了三遍。</p>
<p>作者对于少女青春期心理刻画得非常细致，但是真不真实，我没办法确认（X）。</p>
<p>如果不是我放弃强迫症，强制让自己继续看下去，估计会在维多利亚（也就是主角的姑姑）那段一直停滞下去。</p>
<p>全书从主角无意间听到父母谈论从未谋面的姑姑开始，到她与姑姑结识，认识“下城”里的人，姑姑的言行举止让她感觉到了新鲜，不同阶级的这些人与她日常生活中见到的人完全是两幅面孔。</p>
<p>本来一切虽然改变，但并没有多大改变，直到她无意间看到自己的母亲外遇，而外遇对象正是自己父亲的好朋友、闺蜜的父亲。当然，后面又反转过来，原来自己的父亲本身也一直精神出轨，而出轨对象正是那个好朋友的妻子……</p>
<p>也是因为此事件，主角的父母离婚后，父亲和自己心中的白月光在一起，而自己原先的闺蜜成为自己的妹妹……</p>
<p>虽然我现在写的时候突然觉得这个事情很狗血……但实际读的时候完全没有这种感觉，作者的笔触并没有停留在这些伦理层面，虽然书名叫成年人的谎言生活，但实质上，作者只是借主角的视角稍微展示了点少女眼中那些大人虚伪的一面。</p>
<p>后半段主角第一次喜欢上了别人，对于那一段，作者描述的很直接，“我知道，我的人生会发生改变，我想得到他，我必须得到他。尽管我不信上帝，但我还是会每日每夜祈祷，希望这件事能够成真。唯有这个愿望，这份希望，唯有这个祈祷可以阻止我在当时倒地身亡。”</p>
<p>但我更喜欢这段前面的一段。</p>
<blockquote>
<p>那位个子很高、身体消瘦、佝偻着背的年轻人站起来的那一瞬间，是我消除了周围的声音。我觉得他好像背上吊着一根长长的金色锁链，只有我一个人能看到，他好像悬挂在穹顶上，鞋尖刚好可以触及地板，轻轻地摇晃着。他走到桌子旁，转过身，我一下子看到他天蓝色的眼睛，他深色的皮肤映衬着那双眼睛。那张脸很瘦，有些不和谐，镶嵌在一大堆凌乱的头发和浓密的胡子之间，他的胡须黑得有些发蓝。</p>
</blockquote>
<p>我猜，作者这段是按照耶稣来写的（X）</p>
<p>后面开始，情节变得比较简单，十六岁的主角没有天真地认为自己真的能够和已经有了未婚妻的罗伯特在一起，而且未婚妻还和她早已熟识。她只是忍不住想去和他见面，说话。</p>
<p>然后那个男人，和其他男人也并没有什么区别。</p>
<p>她做好了准备，罗伯特也以为她做好了准备。</p>
<p>只是她最后变了卦，罗伯特依然还是那个谦谦君子。</p>
<blockquote>
<p>我想让自己觉得，我并不是一个平庸、很讨人喜爱、甚至很美的小动物，我要的不是这些。我所期待的事情永远不会发生了，我很痛苦，我带着这种痛苦睡着了。</p>
</blockquote>
<p>我猜罗伯特最后还是会和朱莉安娜结婚。</p>
<p>也许这就是成年人的谎言生活吧……</p>
<p>故事迎来尾声，她选择了在一次无意义的行为中迎来了自己的成年礼。</p>
<p>我很佩服作者这种对于人性细节的敏感，即使我离十几岁的自己已经足够久了，但读这本书的时候，仍然能够常常回忆起当时的种种。</p>
<p>尤其作者写这本书的时候，已经算是奶奶级别的人物了。</p>
<p>这点实在让人钦羡不已。</p>
<p>那不勒斯四部曲已经列入明年书单，期待。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-238-滑动窗口的最大值]]></title>
        <id>https://quwater.github.io/post/Leetcode-238-滑动窗口的最大值/</id>
        <link href="https://quwater.github.io/post/Leetcode-238-滑动窗口的最大值/">
        </link>
        <updated>2020-08-21T12:31:53.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<!--more-->
<h2 id="题解">题解</h2>
<p>第一眼看上去，求每个滑动窗口的最大值，暴力法简单粗暴，很容易编码，时间复杂度大概是 O(n*k)。如果我们稍微处理下，增加一个队列，让队列一直保持递减，最大值永远排在第一个，那么每次求得滑动窗口的最大值的时间复杂度就是 O(1)。</p>
<h3 id="方法一">方法一</h3>
<p>我们优化下暴力求解，只有移动的恰好是最大值时，我们才遍历该滑动窗口求得最大值。</p>
<p>代码如下：</p>
<pre><code class="language-javascript">const maxSlidingWindow = function (nums, k) {
    if (nums.length === 0) {
        return [];
    }
    let max = Math.max(...nums.slice(0, k));
    let res = [max];
    let l = 1;
    let r = k;
    while (r &lt;= nums.length - 1) {
        if (nums[l - 1] !== max) {
            max = Math.max(max, nums[r]);
        } else {
            max = Math.max(...nums.slice(l, r + 1));
        }
        res.push(max);
        l++;
        r++;
    }
    return res;
};
</code></pre>
<h3 id="方法二">方法二</h3>
<p>我们构建一个队列，来存储所有可能成为最大值的数字。开始遍历整个数组，每次加入队列的数如果比队列最末的数要大，那么队列末尾的数肯定不可能为最大值，删掉即可，直到该数值前的数值比它大为止，这样就可以一直保持最大值在队列最前面。</p>
<p>然后我们要注意下最大值从滑动窗口范围移动出去时要去除掉该最大值，而判断移除的临界条件，使用最大值所在的下标会很方便计算。所以我们干脆用队列保存最大值下标而不是最大值。</p>
<p>同时也要考虑，遍历达到窗口长度时，就要每次都添加该窗口的最大值。</p>
<p>代码如下：</p>
<pre><code class="language-JavaScript">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
const maxSlidingWindow = function(nums, k) {
    // 用来保存可能是滑动窗口最大值的下标
    const stack = [];
    const res = [];

    for (let i = 0; i &lt; nums.length; i++) {
        // 最大值的位置要被移除时，删掉
        if (stack[0] &lt;= i - k) {
            stack.shift();
        }
        // 小于新加入的值，那么它们都不可能成为新的最大值，全部删掉
        while (nums[stack[stack.length-1]] &lt;= nums[i]) {
            stack.pop();
        }
        stack.push(i);
        // 达到窗口的长度时，开始添加窗口最大值
        if (i &gt;= k - 1) {
            res.push(nums[stack[0]]);
        }
    }

    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《下一站火星》读后感]]></title>
        <id>https://quwater.github.io/post/下一站火星读后感/</id>
        <link href="https://quwater.github.io/post/下一站火星读后感/">
        </link>
        <updated>2020-08-20T13:30:05.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>如果再看一眼那个光点，你会想到，那时我们的家园和我们的一切。你所爱所知的每个人、听说过乃至存在过的每个人，都在小点上度过一生。欢乐与痛苦、宗教与学说、猎人与强盗、英雄与懦夫、文明创造者与毁灭者、国王与农夫，情侣、父母、儿童，发明家和探险家，还有崇高的教师、腐败的政客、耀眼的明星、伟大的领袖，历史上所有的圣人和罪犯，都住在这里——它只是一粒悬浮在阳光中的微尘。</p>
</blockquote>
<p>最近一段时间是每两年多一次的火星探测窗口期，中国的天问一号和 NASA 的毅力号都已经在前往火星的路上，本来准备在天问一号发射的那天就写完这篇读后感，结果直到前几天才看完这本书，然后又拖了一段时间才上传。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>如果再看一眼那个光点，你会想到，那时我们的家园和我们的一切。你所爱所知的每个人、听说过乃至存在过的每个人，都在小点上度过一生。欢乐与痛苦、宗教与学说、猎人与强盗、英雄与懦夫、文明创造者与毁灭者、国王与农夫，情侣、父母、儿童，发明家和探险家，还有崇高的教师、腐败的政客、耀眼的明星、伟大的领袖，历史上所有的圣人和罪犯，都住在这里——它只是一粒悬浮在阳光中的微尘。</p>
</blockquote>
<p>最近一段时间是每两年多一次的火星探测窗口期，中国的天问一号和 NASA 的毅力号都已经在前往火星的路上，本来准备在天问一号发射的那天就写完这篇读后感，结果直到前几天才看完这本书，然后又拖了一段时间才上传。</p>
<!--more-->
<p>作者是一个我已经关注很久的航天产业的博士，最初还是因为查啤酒相关讯息偶然在知乎上看到了他的答案，他的 ID “太空精酿”还真是完美地将这两个领域融合在了一起。</p>
<p>最初认识到火星这个概念还是在小学二三年级左右的时候。一次去堂哥家玩，看到了一叠《小学生天地》，其中有一期专题就谈到了火星很有可能存在生命。要知道那个时候火星侦查轨道器还没有来到火星，更不用说勇气号与机遇号了。火星上“人脸”的秘密还没有被彻底揭开，记忆里《小学生天地》里还很愉快地讨论着人类能否在下个世纪殖民火星找到火星生命的议题。</p>
<p>至于为什么火星那么特殊，除了太阳系中它位置和地球比较接近外，我那时并没有多少资源去了解相关信息。但起码，这件事在我心中埋下了一颗种子，每次看到“火星”这两个字时，心中都会涌现出希望的这个意象。</p>
<p>直到最近看到了这本《下一站火星》，再一次重新检视起儿时的记忆，不禁感慨，人类从某种程度上来讲，真的太伟大了。肯尼迪在谈到为什么人类要登月时说过，为什么我们要登月，不是因为它简单，而是因为它很难。</p>
<p>人类最伟大的奇迹，都是在迎难而上的过程中诞生的。</p>
<p>本书的故事中，基本上就是苏联和 NASA 在唱双簧，只可惜苏联起了个早床，却赶了个晚集，虽然第一颗人造卫星和第一次载人航天以及第一次太空出舱行走都是苏联率先完成，但是最关键的登月和火星探测，则全部以失败而告终。</p>
<p>如果说一次两次是运气，那么每次都失败，只能说，技不如人了吧。</p>
<p>随着 NASA 对火星的探测的愈发深入，火星之前的神秘面纱也几乎被揭开了大半部分，我们人类之前对它的无数浪漫的幻想几乎全部沦为泡影。</p>
<p>火星由于地质活动几乎停滞，磁场很弱，完全保护不了自己的大气，空气稀薄，导致无法屏蔽宇宙中的各种射线和太阳风，等于说即使火星曾经有过生命，现在也几乎不会存在了，就算现在可能还极少数在苟延残喘，以后也会灭绝。</p>
<p>这颗星球正在走向死寂，我们还是来迟了。</p>
<p>尽管如此，我们未来还是要去选择登陆火星，虽然不太可能寻找到生命的痕迹，但火星作为探测其他星球的基地非常适宜，它自身的引力相较地球低很多，其次也离太阳更远，摆脱太阳的约束也更加轻松，再加上空气稀薄，非常适合发射火箭来探测更远的星系。</p>
<p>而且火星上已经探测出有大量的水冰，直接加热后便可以获取水源，火星土壤中也有大量的高氯酸盐，简单加热也可以获得氧气，此外，火星上的大气虽然稀薄，但主要都是二氧化碳，完全可以用作植物的“粮食来源”。</p>
<p>当然，想要在火星上生存最不能忘记的便是能源，太阳能当然是可选项之一，但并不能得以长期稳定使用，如果可控核聚变技术得以实现，那么从地球带来一点核聚变原料，就可以供火星使用基地很久。</p>
<p>至于我们所需要的材料矿石，火星上蕴藏量极大，即使某些可能难以寻找的矿物质，我们也可以从火星附近的太阳系小行星带寻找到合适小星星，然后利用类似科幻小说中《流浪地球》的技术，采用推进装置将小行星推到火星上，使之成为一颗超大的陨石，接下来作为露天矿藏慢慢开采就行了。</p>
<p>唯一让人感到比较担忧的是，人类能不能够长时间地在太空上生活。当然，考虑到最近这段时间疫情和中美“新冷战”，人类还能不能正常发展下去，还是一个未知数。至于之后那些关于移居到火星上的人如果产生下一代后，他们还算不算是地球人的伦理问题，就只能让未来人来判断了。</p>
<p>人类真的是个矛盾体啊，可以在上世纪六十年代就完成伟大的阿波罗计划登月，后来又通力合作完成国际空间站这么庞大的工程，也可以因意识形态阻止其他国家参与到国际航天事业中来。</p>
<p>不过在看到中美关系风雨飘摇时，NASA 能在天问一号发射成功后发来贺电，还是让人稍微有点慰藉。</p>
<p>虽然这次没能赶上 NASA 的航班，但是已经预定了下一次，期待自己名字留在火星上的那天。也希望在未来的某天自己的名字能搭上中国航天的火箭。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghxm0v83zqj312w0fxdm1.jpg" alt="火星机票" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指Offer56-I.数组中数字出现的次数]]></title>
        <id>https://quwater.github.io/post/剑指Offer56-I-数组中数字出现的次数/</id>
        <link href="https://quwater.github.io/post/剑指Offer56-I-数组中数字出现的次数/">
        </link>
        <updated>2020-08-17T02:56:21.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
</code></pre>
<!--more-->
<h2 id="示例-2">示例 2</h2>
<pre><code>输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
</code></pre>
<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10000</code></li>
</ul>
<h2 id="题解">题解</h2>
<p>这道题的难点在于空间复杂度必须为 <code>O(1)</code>，我们不能建立一个<code>map</code>来统计每个元素的出现数字。这时候就必须用到异或。</p>
<p>但如果只有一个只出现一次的数字，那就好说了，遍历数组用<code>0</code>异或每一个元素即可得到该数字，因为异或同一个数字两次结果不变，最后得到的结果就是那个只出现一次的数字。</p>
<p>此题有两个只出现一次的数字，我们假设那两个数字为<code>a</code>和<code>b</code>， 则最后得到的结果为<code>a</code>异或<code>b</code>。</p>
<p>我们找到<code>a ^ b</code>值为 1 的最低位，根据异或定义可知，<code>a</code>和<code>b</code>在该位值不同，我们完全可以将原数组分为两组，一组与该位异或得到 <code>1</code>，一组得到<code>0</code>，<code>a</code>与<code>b</code>各在一组。</p>
<p>再次两次异或同样数字结果不变的规律，我们很容易得到<code>a</code>与<code>b</code>。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} nums
 * @return {number[]}
 */
const singleNumbers = function(nums) {
    let a = 0;
    let b = 0;
    let c = 0;
  
    nums.forEach((item) =&gt; {
        c ^= item;
    });
  
    let mark = 1;             // 得到分组用的数字
    while((mark &amp; c) === 0) { // 一直到找到第一个1为止 
        mark &lt;&lt;= 1;
    }
  
    // 任何一个数字异或 0 得到该数字本身
    nums.forEach((item) =&gt; {
        // 分组
        if ((mark &amp; item) === 0) { 
            // 出现两次的数字会进行两次异或。
            a ^= item
        } else {
            b ^= item;
        }
    });
  
    return [a, b];
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-130-被围绕的区域]]></title>
        <id>https://quwater.github.io/post/leetcode-130-被围绕的区域/</id>
        <link href="https://quwater.github.io/post/leetcode-130-被围绕的区域/">
        </link>
        <updated>2020-08-11T03:43:39.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>X X X X
X O O X
X X O X
X O X X
</code></pre>
<p>运行你的函数后，矩阵变为：</p>
<pre><code>X X X X
X X X X
X X X X
X O X X
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>X X X X
X O O X
X X O X
X O X X
</code></pre>
<p>运行你的函数后，矩阵变为：</p>
<pre><code>X X X X
X X X X
X X X X
X O X X
</code></pre>
<!--more-->
<h2 id="解释">解释</h2>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是<strong>相连</strong>的。</p>
<h2 id="题解">题解</h2>
<p>我们从区间一圈边界上的'O'开始进行深度优先搜索，将所有与之相连的'O'标记上。</p>
<p>然后遍历区间，将内部所有没有标记上的'O'变成'X'即可。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-JavaScript">const solve = function(board) {
    const m = board.length;
    if (m === 0) {
        return;
    }
    const n = board[0].length;
    let map = {};
    const dfs = function(i, j) {
        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || map[i + '-' + j] || board[i][j] === 'X') {
            return;
        }
        map[i + '-' + j] = 1;
        dfs(i-1, j);
        dfs(i, j-1);
        dfs(i+1, j);
        dfs(i, j+1);
    }
    for (let i = 0; i &lt; m; i++) {
        for (let j = 0; j &lt; n; j++) {
            if ((i === 0 || j === 0 || i === m - 1 || j === n -1) &amp;&amp; board[i][j] === 'O') {
                dfs(i, j);
            }
        }
    }
    for (let i = 1; i &lt; m-1; i++) {
        for (let j = 1; j &lt; n-1; j++) {
            if (!map[i + '-' + j] &amp;&amp; board[i][j] === 'O') {
                board[i][j] = 'X';
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建二维数组时的误区]]></title>
        <id>https://quwater.github.io/post/创建二维数组时的误区/</id>
        <link href="https://quwater.github.io/post/创建二维数组时的误区/">
        </link>
        <updated>2020-08-08T07:41:55.000Z</updated>
        <summary type="html"><![CDATA[<p>在做动态规划类型算法题时，我们总会构建二维数组，但是如果误用了 JavaScript 的一些语法糖，很容易导致意想不到的错误，这里为我自己犯过的错误做一下总结。</p>
<ol>
<li>利用 Array 构建函数，然后 fill 方法内嵌 fill 方法。</li>
</ol>
<pre><code class="language-javascript">const arr = new Array(2).fill(new Array(2).fill(0));
</code></pre>
<p>通过查阅 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">相关文档</a>,我们可以找到这行字：</p>
<blockquote>
<p>当一个对象被传递给 **<code>fill</code>**方法的时候, 填充数组的是这个对象的引用。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>在做动态规划类型算法题时，我们总会构建二维数组，但是如果误用了 JavaScript 的一些语法糖，很容易导致意想不到的错误，这里为我自己犯过的错误做一下总结。</p>
<ol>
<li>利用 Array 构建函数，然后 fill 方法内嵌 fill 方法。</li>
</ol>
<pre><code class="language-javascript">const arr = new Array(2).fill(new Array(2).fill(0));
</code></pre>
<p>通过查阅 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">相关文档</a>,我们可以找到这行字：</p>
<blockquote>
<p>当一个对象被传递给 **<code>fill</code>**方法的时候, 填充数组的是这个对象的引用。</p>
</blockquote>
<!--more-->
<p>这样会导致我们的填充的所谓二维数组，其中数组中的数组其实全部指向一个，牵一发而动全身。</p>
<p>按照上面的例子，如果我们修改一下该二维数组中的<code>arr[0][0]</code>:</p>
<pre><code class="language-javascript">arr[0][0] = 1;
</code></pre>
<p>我们如果以为<code>arr</code>现在是<code>[[1, 0], [0, 0]]</code>，那就大错特错了，其实应该是<code>[[1, 0], [1, 0]]</code>。</p>
<p>因为 <code>arr[0]</code>和<code>arr[1]</code>指向同一个对象，所以改变其中一个，另一个也会一样被改变。</p>
<ol start="2">
<li>利用<code>for...of</code>遍历数组给数组每个元素赋值</li>
</ol>
<pre><code class="language-javascript">const arr = new Array(2);
for (let i of arr) {
    i = new Array(2).fill(0);
}
</code></pre>
<p>乍一看似乎没啥问题，其实这里的 <code>i</code>只是 arr 内部元素的值，将<code>new Array(2).fill(0)</code>赋值给<code>i</code>没有任何意义，我们什么也没改变。</p>
<p>正确方式应该如下：</p>
<pre><code class="language-javascript">const arr = new Array(2);
for (let i = 0; i &lt; arr.length; i++) {
    arr[i] = new Array(2).fill(0);
}
</code></pre>
<p><code>arr[i]</code>为数组内部相应元素的引用，赋值后可以得到对应的二维数组。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-337-打家劫舍III]]></title>
        <id>https://quwater.github.io/post/leetcode-337-打家劫舍III/</id>
        <link href="https://quwater.github.io/post/leetcode-337-打家劫舍III/">
        </link>
        <updated>2020-08-05T02:13:39.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
</blockquote>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \
     3   1

输出: 7
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
</blockquote>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \
     3   1

输出: 7
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
</code></pre>
<!--more-->
<h2 id="示例-2">示例 2</h2>
<pre><code>输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
</code></pre>
<h2 id="题解">题解</h2>
<p>求能盗取的最高金额，我们可以得到每一个节点为根所能够盗取的最高金额，最后分析得到最终根节点所能得到的最高金额。</p>
<p>很明显的动态分析问题。</p>
<p>我们假设<code>f(o)</code>表示 o 节点为根节点，且其房间被盗取的情况下得到的最高金额。<code>g(o)</code>表示 o 节点为根节点，且其房间未被盗取的情况下得到的最高金额。<code>l</code>为<code>o</code>的左节点，<code>r</code>为<code>o</code>的右节点。</p>
<p>则我们很容易得出：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>o</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>l</mi><mo fence="true">)</mo></mrow><mo>+</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>r</mi><mo fence="true">)</mo></mrow><mo>+</mo><mi>o</mi><mi mathvariant="normal">.</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">f\left( o\right) =g\left( l\right) +g\left( r\right)+o.val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">o</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mrow><mo fence="true">(</mo><mi>o</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>f</mi><mrow><mo fence="true">(</mo><mi>l</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>l</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>+</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>f</mi><mrow><mo fence="true">(</mo><mi>r</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>g</mi><mrow><mo fence="true">(</mo><mi>r</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g\left( o\right) =\max \left( f\left( l\right),g\left( l\right)\right) +\max \left( f\left( r\right) ,g\left( r\right) \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">o</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></p>
</li>
</ul>
<p>利用两组 <code>hashmap</code> 即可存储每个节点的两组对应的值，后序遍历得到每个节点对应的值，最后根节点的两值中的最大值即为问题结果。</p>
<p>实际代码中要注意若子节点为空，则其默认的*f(o)<em>和</em>g(o)*都为零。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-JavaScript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const rob = function(root) {
    const f = new Map();
    const g = new Map();
    function dfs(node) {
        if (!node) {
            return;
        }
        dfs(node.left);
        dfs(node.right);
        // 考虑子节点为空的情况
        f.set(node, (g.get(node.left) || 0) + (g.get(node.right) || 0) + node.val);
        g.set(node, Math.max(f.get(node.left) || 0, g.get(node.left) || 0) + Math.max(f.get(node.right) || 0, g.get(node.right) || 0));

    }
    dfs(root)
    // 考虑子节点为空的情况
    return Math.max(f.get(root) || 0, g.get(root) || 0);
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指Offer38.字符串的排列]]></title>
        <id>https://quwater.github.io/post/剑指Offer38-字符串的排列/</id>
        <link href="https://quwater.github.io/post/剑指Offer38-字符串的排列/">
        </link>
        <updated>2020-08-03T00:43:56.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]
</code></pre>
<p><strong>限制：</strong></p>
<pre><code>1 &lt;= s 的长度 &lt;= 8
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</blockquote>
<h2 id="示例">示例</h2>
<pre><code>输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]
</code></pre>
<p><strong>限制：</strong></p>
<pre><code>1 &lt;= s 的长度 &lt;= 8
</code></pre>
<!--more-->
<h2 id="题解">题解</h2>
<p>我们求整个字符串的所有排列，可以看成两步，第一步，将第一个字符和后面所有的字符交换，第二步，固定第一个字符，求后面子字符串的所有排列。</p>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghdfu3ks3wj30n609e3yw.jpg" alt="" loading="lazy"></figure>
<p>很显然，使用递归即可。</p>
<p>当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过，很显然此时使用 set 数据类型即可。</p>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghde7lb5d7j30v40nd75e.jpg" alt="" loading="lazy"></figure>
<h2 id="代码">代码</h2>
<pre><code class="language-javascript">/**
 * @param {string} s
 * @return {string[]}
 */
let res = [],
    c = [];
const permutation = function (s) {
    c = s.split('');
    dfs(0);
    return res;
};
function dfs(begin) {
    // To the last index, no need to exchange
    if (begin === c.length - 1) {
        res.push(c.join(''));
    }
    let set = new Set();
    for (let i = begin; i &lt; c.length; i++) {
        // Deduplication
        if (set.has(c[i])) {
            continue;
        }
        set.add(c[i]);
        // Swap the first character with itself and the following characters
        swap(i, begin);
        dfs(begin + 1);
        swap(i, begin);
    }
}
function swap(a, b) {
    [c[a], c[b]] = [c[b], c[a]];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[剑指Offer33.二叉搜索树的后序遍历序列]]></title>
        <id>https://quwater.github.io/post/剑指Offer33-二叉搜索树的后序遍历序列/</id>
        <link href="https://quwater.github.io/post/剑指Offer33-二叉搜索树的后序遍历序列/">
        </link>
        <updated>2020-07-29T04:15:13.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
</blockquote>
<pre><code>     5
    / \
   2   6
  / \
 1   3
</code></pre>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入: [1,6,3,2,5]
输出: false
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="题干">题干</h1>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
</blockquote>
<pre><code>     5
    / \
   2   6
  / \
 1   3
</code></pre>
<h2 id="示例-1">示例 1</h2>
<pre><code>输入: [1,6,3,2,5]
输出: false
</code></pre>
<!--more-->
<h2 id="示例-2">示例 2</h2>
<pre><code>输入: [1,3,2,6,5]
输出: true
</code></pre>
<p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<h2 id="题解">题解</h2>
<p>后序遍历的特点是，根节点在最后一位。且前半部分节点的值都小于根节点的值，后半部分的值都大于根节点的值，只要我们通过遍历数组，找到第一个大于根节点值的节点，则很容易将数组分为两部分，通过递归很容易得出最后结果。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-javascript">/**
 * @param {number[]} postorder
 * @return {boolean}
 */
const verifyPostorder = function(postorder) {
    return recur(postorder, 0, postorder.length - 1);
};
const recur = function(postorder, i, j) {
    if (i &gt;= j) {
        return true;
    } 
    let p = i;
    // 找出第一个大于根节点的数
    while (postorder[p] &lt; postorder[j]) {
        p++;
    } 
    let m = p;
    while (postorder[p] &gt; postorder[j]) {
        p++;
    } 
    // 右半部全部大于根节点则 p === j
    return p === j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);
};
</code></pre>
]]></content>
    </entry>
</feed>